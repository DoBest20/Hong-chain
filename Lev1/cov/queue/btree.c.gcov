        -:    0:Source:btree.c
        -:    0:Graph:btree.gcno
        -:    0:Data:btree.gcda
        -:    0:Runs:146
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <assert.h>
        -:    4:
        -:    5:#define MAX 4
        -:    6:#define MIN 2
        -:    7:
        -:    8:#define NUM_TEST_INPUT 100
        -:    9:
        -:   10:struct btreeNode {
        -:   11:	int val[MAX + 1], count;
        -:   12:	struct btreeNode *link[MAX + 1];
        -:   13:};
        -:   14:
        -:   15:struct btreeNode *root;
        -:   16:
        -:   17:/* creating new node */
      365:   18:struct btreeNode * createNode(int val, struct btreeNode *child) {
      365:   19:	struct btreeNode *newNode;
      365:   20:	newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));
      365:   21:	newNode->val[1] = val;
      365:   22:	newNode->count = 1;
      365:   23:	newNode->link[0] = root;
      365:   24:	newNode->link[1] = child;
      730:   25:	return newNode;
      365:   26:}
        -:   27:
        -:   28:/* Places the value in appropriate position */
     3056:   29:void addValToNode(int val, int pos, struct btreeNode *node,
        -:   30:		struct btreeNode *child) {
     3056:   31:	int j = node->count;
    12974:   32:	while (j > pos) {
     3431:   33:		node->val[j + 1] = node->val[j];
     3431:   34:		node->link[j + 1] = node->link[j];
     3431:   35:		j--;
        -:   36:	}
     3056:   37:	node->val[j + 1] = val;
     3056:   38:	node->link[j + 1] = child;
     3056:   39:	node->count++;
     3056:   40:}
        -:   41:
        -:   42:/* split the node */
      724:   43:void splitNode (int val, int *pval, int pos, struct btreeNode *node,
        -:   44:		struct btreeNode *child, struct btreeNode **newNode) {
      724:   45:	int median, j;
        -:   46:
      724:   47:	if (pos > MIN)
      343:   48:		median = MIN + 1;
        -:   49:	else
      381:   50:		median = MIN;
        -:   51:
      724:   52:	*newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));
      724:   53:	j = median + 1;
     3658:   54:	while (j <= MAX) {
     1105:   55:		(*newNode)->val[j - median] = node->val[j];
     1105:   56:		(*newNode)->link[j - median] = node->link[j];
     1105:   57:		j++;
        -:   58:	}
      724:   59:	node->count = median;
      724:   60:	(*newNode)->count = MAX - median;
        -:   61:
      724:   62:	if (pos <= MIN) {
      381:   63:		addValToNode(val, pos, node, child);
      381:   64:	} else {
      343:   65:		addValToNode(val, pos - median, *newNode, child);
        -:   66:	}
      724:   67:	*pval = node->val[node->count];
      724:   68:	(*newNode)->link[0] = node->link[node->count];
      724:   69:	node->count--;
      724:   70:}
        -:   71:
        -:   72:/* sets the value val in the node */
    13140:   73:int setValueInNode(int val, int *pval,
        -:   74:		struct btreeNode *node, struct btreeNode **child) {
        -:   75:
    13140:   76:	int pos;
    13140:   77:	if (!node) {
     2697:   78:		*pval = val;
     2697:   79:		*child = NULL;
     2697:   80:		return 1;
        -:   81:	}
        -:   82:	
        -:   83:	// if (node->link[pos] == NULL) {
        -:   84:	// 	exit(1);
        -:   85:	// }
        -:   86:	
        -:   87:
    10443:   88:	if (val < node->val[1]) {
     2626:   89:		pos = 0;
     2626:   90:	} else {
    33196:   91:		for (pos = node->count;
    25379:   92:				(val < node->val[pos] && pos > 1); pos--);
     7817:   93:		if (val == node->val[pos]) {
     2797:   94:			printf("Duplicates not allowed\n");
     2797:   95:			return 0;
        -:   96:		}
        -:   97:	}
     7646:   98:	if (setValueInNode(val, pval, node->link[pos], child)) {
     3056:   99:		if (node->count < MAX) {
     2332:  100:			addValToNode(*pval, pos, node, *child);
     2332:  101:		} else {
      724:  102:			splitNode(*pval, pval, pos, node, *child, child);
      724:  103:			return 1;
        -:  104:		}
     2332:  105:	}
     6922:  106:	return 0;
    13140:  107:}
        -:  108:
        -:  109:/* insert val in B-Tree */
     5494:  110:void insertion(int val) {
     5494:  111:	int flag, i;
     5494:  112:	struct btreeNode *child;
        -:  113:
     5494:  114:	flag = setValueInNode(val, &i, root, &child);
     5494:  115:	if (flag)
      365:  116:		root = createNode(i, child);
     5494:  117:}
        -:  118:
        -:  119:/* copy successor for the value to be deleted */
       44:  120:void copySuccessor(struct btreeNode *myNode, int pos) {
       44:  121:	struct btreeNode *dummy;
       44:  122:	dummy = myNode->link[pos];
        -:  123:
      106:  124:	for (;dummy->link[0] != NULL;)
        9:  125:		dummy = dummy->link[0];
       44:  126:	myNode->val[pos] = dummy->val[1];
        -:  127:
       44:  128:}
        -:  129:
        -:  130:/* removes the value from the given node and rearrange values */
      188:  131:void removeVal(struct btreeNode *myNode, int pos) {
      188:  132:	int i = pos + 1;
      816:  133:	while (i <= myNode->count) {
      220:  134:		myNode->val[i - 1] = myNode->val[i];
      220:  135:		myNode->link[i - 1] = myNode->link[i];
      220:  136:		i++;
        -:  137:	}
      188:  138:	myNode->count--;
      188:  139:}
        -:  140:
        -:  141:/* shifts value from parent to right child */
    #####:  142:void doRightShift(struct btreeNode *myNode, int pos) {
    #####:  143:	struct btreeNode *x = myNode->link[pos];
    #####:  144:	int j = x->count;
        -:  145:
    #####:  146:	while (j > 0) {
    #####:  147:		x->val[j + 1] = x->val[j];
    #####:  148:		x->link[j + 1] = x->link[j];
        -:  149:	}
    #####:  150:	x->val[1] = myNode->val[pos];
    #####:  151:	x->link[1] = x->link[0];
    #####:  152:	x->count++;
        -:  153:
    #####:  154:	x = myNode->link[pos - 1];
    #####:  155:	myNode->val[pos] = x->val[x->count];
    #####:  156:	myNode->link[pos] = x->link[x->count];
    #####:  157:	x->count--;
        -:  158:	return;
    #####:  159:}
        -:  160:
        -:  161:/* shifts value from parent to left child */
       32:  162:void doLeftShift(struct btreeNode *myNode, int pos) {
       32:  163:	int j = 1;
       32:  164:	struct btreeNode *x = myNode->link[pos - 1];
        -:  165:
       32:  166:	x->count++;
       32:  167:	x->val[x->count] = myNode->val[pos];
       32:  168:	x->link[x->count] = myNode->link[pos]->link[0];
        -:  169:
       32:  170:	x = myNode->link[pos];
       32:  171:	myNode->val[pos] = x->val[1];
       32:  172:	x->link[0] = x->link[1];
       32:  173:	x->count--;
        -:  174:
      218:  175:	while (j <= x->count) {
       77:  176:		x->val[j] = x->val[j + 1];
       77:  177:		x->link[j] = x->link[j + 1];
       77:  178:		j++;
        -:  179:	}
        -:  180:	return;
       32:  181:}
        -:  182:
        -:  183:/* merge nodes */
       62:  184:void mergeNodes(struct btreeNode *myNode, int pos) {
       62:  185:	int j = 1;
       62:  186:	struct btreeNode *x1 = myNode->link[pos], *x2 = myNode->link[pos - 1];
        -:  187:
       62:  188:	x2->count++;
       62:  189:	x2->val[x2->count] = myNode->val[pos];
       62:  190:	x2->link[x2->count] = myNode->link[0];
        -:  191:
      308:  192:	while (j <= x1->count) {
       92:  193:		x2->count++;
       92:  194:		x2->val[x2->count] = x1->val[j];
       92:  195:		x2->link[x2->count] = x1->link[j];
       92:  196:		j++;
        -:  197:	}
        -:  198:
       62:  199:	j = pos;
      200:  200:	while (j < myNode->count) {
       38:  201:		myNode->val[j] = myNode->val[j + 1];
       38:  202:		myNode->link[j] = myNode->link[j + 1];
       38:  203:		j++;
        -:  204:	}
       62:  205:	myNode->count--;
       62:  206:	free(x1);
       62:  207:}
        -:  208:
        -:  209:/* adjusts the given node */
       94:  210:void adjustNode(struct btreeNode *myNode, int pos) {
       94:  211:	if (!pos) {
       46:  212:		if (myNode->link[1]->count > MIN) {
       16:  213:			doLeftShift(myNode, 1);
       16:  214:		} else {
       30:  215:			mergeNodes(myNode, 1);
        -:  216:		}
       46:  217:	} else {
       48:  218:		if (myNode->count != pos) {
       28:  219:			if(myNode->link[pos - 1]->count > MIN) {
    #####:  220:				doRightShift(myNode, pos);
    #####:  221:			} else {
       28:  222:				if (myNode->link[pos + 1]->count > MIN) {
       16:  223:					doLeftShift(myNode, pos + 1);
       16:  224:				} else {
       12:  225:					mergeNodes(myNode, pos);
        -:  226:				}
        -:  227:			}
       28:  228:		} else {
       20:  229:			if (myNode->link[pos - 1]->count > MIN)
    #####:  230:				doRightShift(myNode, pos);
        -:  231:			else
       20:  232:				mergeNodes(myNode, pos);
        -:  233:		}
        -:  234:	}
       94:  235:}
        -:  236:
        -:  237:/* delete val from the node */
    12160:  238:int delValFromNode(int val, struct btreeNode *myNode) {
    12160:  239:	int pos, flag = 0;
    12160:  240:	if (myNode) {
     8229:  241:		if (val < myNode->val[1]) {
     2896:  242:			pos = 0;
     2896:  243:			flag = 0;
     2896:  244:		} else {
    21424:  245:			for (pos = myNode->count;
    16091:  246:					(val < myNode->val[pos] && pos > 1); pos--);
     5333:  247:			if (val == myNode->val[pos]) {
      232:  248:				flag = 1;
      232:  249:			} else {
     5101:  250:				flag = 0;
        -:  251:			}
        -:  252:		}
     8229:  253:		if (flag) {
      232:  254:			if (myNode->link[pos - 1]) {
       44:  255:				copySuccessor(myNode, pos);
       44:  256:				flag = delValFromNode(myNode->val[pos], myNode->link[pos]);
       44:  257:				if (flag == 0) {
    #####:  258:					printf("Given data is not present in B-Tree\n");
    #####:  259:				}
       44:  260:			} else {
      188:  261:				removeVal(myNode, pos);
        -:  262:			}
      232:  263:		} else {
     7997:  264:			flag = delValFromNode(val, myNode->link[pos]);
        -:  265:		}
     8229:  266:		if (myNode->link[pos]) {
     4323:  267:			if (myNode->link[pos]->count < MIN)
       94:  268:				adjustNode(myNode, pos);
     4323:  269:		}
     8229:  270:	}
    24320:  271:	return flag;
    12160:  272:}
        -:  273:
        -:  274:/* delete val from B-tree */
     4119:  275:void deletion(int val, struct btreeNode *myNode) {
     4119:  276:	struct btreeNode *tmp;
     4119:  277:	if (!delValFromNode(val, myNode)) {
     3931:  278:		printf("Given value is not present in B-Tree\n");
     3931:  279:		return;
        -:  280:	} else {
      188:  281:		if (myNode->count == 0) {
       29:  282:			tmp = myNode;
       29:  283:			myNode = myNode->link[0];
       29:  284:			free(tmp);
       29:  285:		}
        -:  286:	}
      188:  287:	root = myNode;
      188:  288:	return;
     4119:  289:}
        -:  290:
        -:  291:/* search val in B-Tree */
     8417:  292:void searching(int val, int *pos, struct btreeNode *myNode) {
     8417:  293:	if (!myNode) {
     2380:  294:		return;
        -:  295:	}
        -:  296:
     6037:  297:	if (val < myNode->val[1]) {
     1388:  298:		*pos = 0;
     1388:  299:	} else {
    17854:  300:		for (*pos = myNode->count;
    13205:  301:				(val < myNode->val[*pos] && *pos > 1); (*pos)--);
     4649:  302:		if (val == myNode->val[*pos]) {
      469:  303:			printf("Given data %d is present in B-Tree", val);
      469:  304:			return;
        -:  305:		}
        -:  306:	}
     5568:  307:	searching(val, pos, myNode->link[*pos]);
     5568:  308:	return;
     8417:  309:}
        -:  310:
        -:  311:/* B-Tree Traversal */
     6715:  312:void traversal(struct btreeNode *myNode) {
     6715:  313:	int i;
     6715:  314:	if (myNode) {
    12604:  315:		for (i = 0; i < myNode->count; i++) {
     4660:  316:			traversal(myNode->link[i]);
     4660:  317:			printf("%d ", myNode->val[i + 1]);
     4660:  318:		}
     1642:  319:		traversal(myNode->link[i]);
     1642:  320:	}
     6715:  321:}
        -:  322:
      146:  323:int main() {
      146:  324:	int val, ch;
      146:  325:	int cnt = NUM_TEST_INPUT;
    28212:  326:	while (cnt--) {
    13967:  327:		printf("1. Insertion\t2. Deletion\n");
    13967:  328:		printf("3. Searching\t4. Traversal\n");
    13967:  329:		printf("5. Exit\nEnter your choice:");
    13967:  330:		scanf("%d", &ch);
    13967:  331:		switch (ch) {
        -:  332:			case 1:
     5494:  333:				printf("Enter your input:");
     5494:  334:				scanf("%d", &val);
     5494:  335:				insertion(val);
     5494:  336:				break;
        -:  337:			case 2:
     4119:  338:				printf("Enter the element to delete:");
     4119:  339:				scanf("%d", &val);
     4119:  340:				deletion(val, root);
     4119:  341:				break;
        -:  342:			case 3:
     2849:  343:				printf("Enter the element to search:");
     2849:  344:				scanf("%d", &val);
     2849:  345:				searching(val, &ch, root);
     2849:  346:				break;
        -:  347:			case 4:
      413:  348:				traversal(root);
      413:  349:				break;
        -:  350:			case 5:
        7:  351:				exit(0);
        -:  352:			default:
     1085:  353:				printf("U have entered wrong option!!\n");
     1085:  354:				break;
        -:  355:		}
    13960:  356:		printf("\n");
        -:  357:	}
      139:  358:}

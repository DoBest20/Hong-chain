        -:    0:Source:btree.c
        -:    0:Graph:btree.gcno
        -:    0:Data:btree.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <assert.h>
        -:    4:
        -:    5:#define MAX 4
        -:    6:#define MIN 2
        -:    7:
        -:    8:#define NUM_TEST_INPUT 100
        -:    9:
        -:   10:struct btreeNode {
        -:   11:	int val[MAX + 1], count;
        -:   12:	struct btreeNode *link[MAX + 1];
        -:   13:};
        -:   14:
        -:   15:struct btreeNode *root;
        -:   16:
        -:   17:/* creating new node */
        2:   18:struct btreeNode * createNode(int val, struct btreeNode *child) {
        -:   19:	struct btreeNode *newNode;
        2:   20:	newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));
        2:   21:	newNode->val[1] = val;
        2:   22:	newNode->count = 1;
        2:   23:	newNode->link[0] = root;
        2:   24:	newNode->link[1] = child;
        2:   25:	return newNode;
        -:   26:}
        -:   27:
        -:   28:/* Places the value in appropriate position */
       22:   29:void addValToNode(int val, int pos, struct btreeNode *node,
        -:   30:		struct btreeNode *child) {
       22:   31:	int j = node->count;
       75:   32:	while (j > pos) {
       31:   33:		node->val[j + 1] = node->val[j];
       31:   34:		node->link[j + 1] = node->link[j];
       31:   35:		j--;
        -:   36:	}
       22:   37:	node->val[j + 1] = val;
       22:   38:	node->link[j + 1] = child;
       22:   39:	node->count++;
       22:   40:}
        -:   41:
        -:   42:/* split the node */
        5:   43:void splitNode (int val, int *pval, int pos, struct btreeNode *node,
        -:   44:		struct btreeNode *child, struct btreeNode **newNode) {
        -:   45:	int median, j;
        -:   46:
        5:   47:	if (pos > MIN)
        1:   48:		median = MIN + 1;
        -:   49:	else
        4:   50:		median = MIN;
        -:   51:
        5:   52:	*newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));
        5:   53:	j = median + 1;
       19:   54:	while (j <= MAX) {
        9:   55:		(*newNode)->val[j - median] = node->val[j];
        9:   56:		(*newNode)->link[j - median] = node->link[j];
        9:   57:		j++;
        -:   58:	}
        5:   59:	node->count = median;
        5:   60:	(*newNode)->count = MAX - median;
        -:   61:
        5:   62:	if (pos <= MIN) {
        4:   63:		addValToNode(val, pos, node, child);
        -:   64:	} else {
        1:   65:		addValToNode(val, pos - median, *newNode, child);
        -:   66:	}
        5:   67:	*pval = node->val[node->count];
        5:   68:	(*newNode)->link[0] = node->link[node->count];
        5:   69:	node->count--;
        5:   70:}
        -:   71:
        -:   72:/* sets the value val in the node */
       53:   73:int setValueInNode(int val, int *pval,
        -:   74:		struct btreeNode *node, struct btreeNode **child) {
        -:   75:
        -:   76:	int pos;
       53:   77:	if (!node) {
       19:   78:		*pval = val;
       19:   79:		*child = NULL;
       19:   80:		return 1;
        -:   81:	}
        -:   82:	
        -:   83:	// if (node->link[pos] == NULL) {
        -:   84:	// 	exit(1);
        -:   85:	// }
        -:   86:	
        -:   87:
       34:   88:	if (val < node->val[1]) {
       14:   89:		pos = 0;
        -:   90:	} else {
       58:   91:		for (pos = node->count;
       36:   92:				(val < node->val[pos] && pos > 1); pos--);
       20:   93:		if (val == node->val[pos]) {
        1:   94:			printf("Duplicates not allowed\n");
        1:   95:			return 0;
        -:   96:		}
        -:   97:	}
       33:   98:	if (setValueInNode(val, pval, node->link[pos], child)) {
       22:   99:		if (node->count < MAX) {
       17:  100:			addValToNode(*pval, pos, node, *child);
        -:  101:		} else {
        5:  102:			splitNode(*pval, pval, pos, node, *child, child);
        5:  103:			return 1;
        -:  104:		}
        -:  105:	}
       28:  106:	return 0;
        -:  107:}
        -:  108:
        -:  109:/* insert val in B-Tree */
       20:  110:void insertion(int val) {
       20:  111:	int flag, i;
       20:  112:	struct btreeNode *child;
        -:  113:
       20:  114:	flag = setValueInNode(val, &i, root, &child);
       20:  115:	if (flag)
        2:  116:		root = createNode(i, child);
       20:  117:}
        -:  118:
        -:  119:/* copy successor for the value to be deleted */
        1:  120:void copySuccessor(struct btreeNode *myNode, int pos) {
        -:  121:	struct btreeNode *dummy;
        1:  122:	dummy = myNode->link[pos];
        -:  123:
        2:  124:	for (;dummy->link[0] != NULL;)
    #####:  125:		dummy = dummy->link[0];
        1:  126:	myNode->val[pos] = dummy->val[1];
        -:  127:
        1:  128:}
        -:  129:
        -:  130:/* removes the value from the given node and rearrange values */
        2:  131:void removeVal(struct btreeNode *myNode, int pos) {
        2:  132:	int i = pos + 1;
        5:  133:	while (i <= myNode->count) {
        1:  134:		myNode->val[i - 1] = myNode->val[i];
        1:  135:		myNode->link[i - 1] = myNode->link[i];
        1:  136:		i++;
        -:  137:	}
        2:  138:	myNode->count--;
        2:  139:}
        -:  140:
        -:  141:/* shifts value from parent to right child */
    #####:  142:void doRightShift(struct btreeNode *myNode, int pos) {
    #####:  143:	struct btreeNode *x = myNode->link[pos];
    #####:  144:	int j = x->count;
        -:  145:
    #####:  146:	while (j > 0) {
    #####:  147:		x->val[j + 1] = x->val[j];
    #####:  148:		x->link[j + 1] = x->link[j];
        -:  149:	}
    #####:  150:	x->val[1] = myNode->val[pos];
    #####:  151:	x->link[1] = x->link[0];
    #####:  152:	x->count++;
        -:  153:
    #####:  154:	x = myNode->link[pos - 1];
    #####:  155:	myNode->val[pos] = x->val[x->count];
    #####:  156:	myNode->link[pos] = x->link[x->count];
    #####:  157:	x->count--;
    #####:  158:	return;
        -:  159:}
        -:  160:
        -:  161:/* shifts value from parent to left child */
    #####:  162:void doLeftShift(struct btreeNode *myNode, int pos) {
    #####:  163:	int j = 1;
    #####:  164:	struct btreeNode *x = myNode->link[pos - 1];
        -:  165:
    #####:  166:	x->count++;
    #####:  167:	x->val[x->count] = myNode->val[pos];
    #####:  168:	x->link[x->count] = myNode->link[pos]->link[0];
        -:  169:
    #####:  170:	x = myNode->link[pos];
    #####:  171:	myNode->val[pos] = x->val[1];
    #####:  172:	x->link[0] = x->link[1];
    #####:  173:	x->count--;
        -:  174:
    #####:  175:	while (j <= x->count) {
    #####:  176:		x->val[j] = x->val[j + 1];
    #####:  177:		x->link[j] = x->link[j + 1];
    #####:  178:		j++;
        -:  179:	}
    #####:  180:	return;
        -:  181:}
        -:  182:
        -:  183:/* merge nodes */
        2:  184:void mergeNodes(struct btreeNode *myNode, int pos) {
        2:  185:	int j = 1;
        2:  186:	struct btreeNode *x1 = myNode->link[pos], *x2 = myNode->link[pos - 1];
        -:  187:
        2:  188:	x2->count++;
        2:  189:	x2->val[x2->count] = myNode->val[pos];
        2:  190:	x2->link[x2->count] = myNode->link[0];
        -:  191:
        7:  192:	while (j <= x1->count) {
        3:  193:		x2->count++;
        3:  194:		x2->val[x2->count] = x1->val[j];
        3:  195:		x2->link[x2->count] = x1->link[j];
        3:  196:		j++;
        -:  197:	}
        -:  198:
        2:  199:	j = pos;
       10:  200:	while (j < myNode->count) {
        6:  201:		myNode->val[j] = myNode->val[j + 1];
        6:  202:		myNode->link[j] = myNode->link[j + 1];
        6:  203:		j++;
        -:  204:	}
        2:  205:	myNode->count--;
        2:  206:	free(x1);
        2:  207:}
        -:  208:
        -:  209:/* adjusts the given node */
        2:  210:void adjustNode(struct btreeNode *myNode, int pos) {
        2:  211:	if (!pos) {
        1:  212:		if (myNode->link[1]->count > MIN) {
    #####:  213:			doLeftShift(myNode, 1);
        -:  214:		} else {
        1:  215:			mergeNodes(myNode, 1);
        -:  216:		}
        -:  217:	} else {
        1:  218:		if (myNode->count != pos) {
        1:  219:			if(myNode->link[pos - 1]->count > MIN) {
    #####:  220:				doRightShift(myNode, pos);
        -:  221:			} else {
        1:  222:				if (myNode->link[pos + 1]->count > MIN) {
    #####:  223:					doLeftShift(myNode, pos + 1);
        -:  224:				} else {
        1:  225:					mergeNodes(myNode, pos);
        -:  226:				}
        -:  227:			}
        -:  228:		} else {
    #####:  229:			if (myNode->link[pos - 1]->count > MIN)
    #####:  230:				doRightShift(myNode, pos);
        -:  231:			else
    #####:  232:				mergeNodes(myNode, pos);
        -:  233:		}
        -:  234:	}
        2:  235:}
        -:  236:
        -:  237:/* delete val from the node */
      185:  238:int delValFromNode(int val, struct btreeNode *myNode) {
      185:  239:	int pos, flag = 0;
      185:  240:	if (myNode) {
      124:  241:		if (val < myNode->val[1]) {
       59:  242:			pos = 0;
       59:  243:			flag = 0;
        -:  244:		} else {
      300:  245:			for (pos = myNode->count;
      340:  246:					(val < myNode->val[pos] && pos > 1); pos--);
       65:  247:			if (val == myNode->val[pos]) {
        3:  248:				flag = 1;
        -:  249:			} else {
       62:  250:				flag = 0;
        -:  251:			}
        -:  252:		}
      124:  253:		if (flag) {
        3:  254:			if (myNode->link[pos - 1]) {
        1:  255:				copySuccessor(myNode, pos);
        1:  256:				flag = delValFromNode(myNode->val[pos], myNode->link[pos]);
        1:  257:				if (flag == 0) {
    #####:  258:					printf("Given data is not present in B-Tree\n");
        -:  259:				}
        -:  260:			} else {
        2:  261:				removeVal(myNode, pos);
        -:  262:			}
        -:  263:		} else {
      121:  264:			flag = delValFromNode(val, myNode->link[pos]);
        -:  265:		}
      124:  266:		if (myNode->link[pos]) {
       61:  267:			if (myNode->link[pos]->count < MIN)
        2:  268:				adjustNode(myNode, pos);
        -:  269:		}
        -:  270:	}
      185:  271:	return flag;
        -:  272:}
        -:  273:
        -:  274:/* delete val from B-tree */
       63:  275:void deletion(int val, struct btreeNode *myNode) {
        -:  276:	struct btreeNode *tmp;
       63:  277:	if (!delValFromNode(val, myNode)) {
       61:  278:		printf("Given value is not present in B-Tree\n");
       61:  279:		return;
        -:  280:	} else {
        2:  281:		if (myNode->count == 0) {
    #####:  282:			tmp = myNode;
    #####:  283:			myNode = myNode->link[0];
    #####:  284:			free(tmp);
        -:  285:		}
        -:  286:	}
        2:  287:	root = myNode;
        2:  288:	return;
        -:  289:}
        -:  290:
        -:  291:/* search val in B-Tree */
       43:  292:void searching(int val, int *pos, struct btreeNode *myNode) {
       43:  293:	if (!myNode) {
       14:  294:		return;
        -:  295:	}
        -:  296:
       29:  297:	if (val < myNode->val[1]) {
        4:  298:		*pos = 0;
        -:  299:	} else {
       59:  300:		for (*pos = myNode->count;
       18:  301:				(val < myNode->val[*pos] && *pos > 1); (*pos)--);
       25:  302:		if (val == myNode->val[*pos]) {
        2:  303:			printf("Given data %d is present in B-Tree", val);
        2:  304:			return;
        -:  305:		}
        -:  306:	}
       27:  307:	searching(val, pos, myNode->link[*pos]);
       27:  308:	return;
        -:  309:}
        -:  310:
        -:  311:/* B-Tree Traversal */
    #####:  312:void traversal(struct btreeNode *myNode) {
        -:  313:	int i;
    #####:  314:	if (myNode) {
    #####:  315:		for (i = 0; i < myNode->count; i++) {
    #####:  316:			traversal(myNode->link[i]);
    #####:  317:			printf("%d ", myNode->val[i + 1]);
        -:  318:		}
    #####:  319:		traversal(myNode->link[i]);
        -:  320:	}
    #####:  321:}
        -:  322:
        1:  323:int main() {
        1:  324:	int val, ch;
        1:  325:	int cnt = NUM_TEST_INPUT;
      102:  326:	while (cnt--) {
      100:  327:		printf("1. Insertion\t2. Deletion\n");
      100:  328:		printf("3. Searching\t4. Traversal\n");
      100:  329:		printf("5. Exit\nEnter your choice:");
      100:  330:		scanf("%d", &ch);
      100:  331:		switch (ch) {
       20:  332:			case 1:
       20:  333:				printf("Enter your input:");
       20:  334:				scanf("%d", &val);
       20:  335:				insertion(val);
       20:  336:				break;
       63:  337:			case 2:
       63:  338:				printf("Enter the element to delete:");
       63:  339:				scanf("%d", &val);
       63:  340:				deletion(val, root);
       63:  341:				break;
       16:  342:			case 3:
       16:  343:				printf("Enter the element to search:");
       16:  344:				scanf("%d", &val);
       16:  345:				searching(val, &ch, root);
       16:  346:				break;
    #####:  347:			case 4:
    #####:  348:				traversal(root);
    #####:  349:				break;
    #####:  350:			case 5:
    #####:  351:				exit(0);
        1:  352:			default:
        1:  353:				printf("U have entered wrong option!!\n");
        1:  354:				break;
        -:  355:		}
      100:  356:		printf("\n");
        -:  357:	}
        -:  358:}
